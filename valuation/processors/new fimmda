import * as XLSX from 'xlsx';
import { PrismaClient } from '@prisma/client';
import { ProcessingResult, FIMMDA_COLUMN_MAPPING } from '../valuationTypes';
import { BaseFileProcessor } from './BaseFileProcessor';
import { mapRowToRecord, normalizeHeader, RowMappingError } from './common/RowMappingUtils';

export class FIMMDAProcessor extends BaseFileProcessor {
  constructor(prisma: PrismaClient) {
    super(prisma);
  }

  async processFile(file: Express.Multer.File, batchId: string): Promise<ProcessingResult> {
    try {
      const workbook = XLSX.read(file.buffer, {
        type: 'buffer',
        cellDates: true,
        dateNF: 'dd-mmm-yyyy'
      });

      const sheetsToProcess = ['details'];
      let allRecords: any[] = [];
      let errors: RowMappingError[] = [];

      for (const sheetNameKey of sheetsToProcess) {
        const sheetName = Object.keys(workbook.Sheets).find(
          name => name.toLowerCase() === sheetNameKey
        );

        if (!sheetName) {
          console.warn(`Sheet "${sheetNameKey}" not found.`);
          continue;
        }

        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, {
          header: 1,
          raw: false,
          dateNF: 'dd-mmm-yyyy'
        });

        const headerRowIndex = this.findHeaderRow(jsonData);
        if (headerRowIndex === -1) {
          console.warn(`Header row not found in "${sheetNameKey}" sheet.`);
          continue;
        }

        const headers = (jsonData[headerRowIndex] as string[]).map(h =>
          h ? normalizeHeader(h.toString()) : ''
        );

        for (let i = headerRowIndex + 1; i < jsonData.length; i++) {
          const row = jsonData[i] as any[];
          if (!row || row.length === 0) continue;

          const record = mapRowToRecord(
            headers,
            row,
            i,
            FIMMDA_COLUMN_MAPPING,
            ['isin', 'marketPrice', 'category'],
            errors
          );

          if (record) {
            allRecords.push(record);
          }
        }
      }

      // Clear old data
      await this.prisma.fIMMDA.deleteMany({});

      // Insert into DB
      let processedRecords = 0;
      let errorRecords = 0;

      for (const record of allRecords) {
        try {
          const processedRecord = this.processRecord(record, batchId);
          await this.prisma.fIMMDA.create({ data: processedRecord });
          processedRecords++;
        } catch (err) {
          console.error('DB Error:', err);
          errorRecords++;
        }
      }

      return {
        totalRecords: allRecords.length,
        processedRecords,
        errorRecords,
        errors,
      };
    } catch (error) {
      console.error('FIMMDA file error:', error);
      throw error;
    }
  }

  private findHeaderRow(data: any[]): number {
    for (let i = 0; i < Math.min(data.length, 20); i++) {
      const row = data[i];
      if (!row || !Array.isArray(row)) continue;

      const lowerRow = row.map(cell =>
        cell ? normalizeHeader(cell.toString()) : ''
      );

      const hasISIN = lowerRow.some(h => h.includes('isin'));
      const hasMarketPrice = lowerRow.some(h => h.includes('market price'));
      const hasCategory = lowerRow.some(h => h.includes('category'));
      const hasMarketValu = lowerRow.some(h => h.includes('mp as per valuation'));
      const hasDifference = lowerRow.some(h => h.includes('difference'));

      if (hasISIN && hasMarketPrice && hasCategory && hasMarketValu && hasDifference) {
        return i;
      }
    }
    return -1;
  }

  private processRecord(record: any, batchId: string): any {
    return {
      isin: record.isin,
      instrumentId: record.instrumentId,
      portfolio: record.portfolio,
      securityName: record.securityName,
      category: record.category,
      subCategory: record.subCategory,
      instrumentType: record.instrumentType,
      slrNslr: record.slrNslr,
      issuer: record.issuer,
      quantity: parseFloat(record.quantity),
      faceValue: parseFloat(record.faceValue),
      wap: parseFloat(record.wap),
      bookValue: parseFloat(record.bookValue),
      maturityDate: this.parseDate(record.maturityDate),
      coupon: parseFloat(record.coupon),
      marketValue: parseFloat(record.marketValue),
      marketPrice: parseFloat(record.marketPrice),
      marketPriceValuation: parseFloat(record.marketPriceValuation),
      difference: parseFloat(record.difference),
      marketYield: parseFloat(record.marketYield),
      appreciation: parseFloat(record.appreciation),
      depreciation: parseFloat(record.depreciation),
      valuationDate: this.parseDate(record.valuationDate),
      faceValuePerUnit: parseFloat(record.faceValuePerUnit),
      currentYield: parseFloat(record.currentYield),
      uploadBatchId: batchId,
    };
  }
}
