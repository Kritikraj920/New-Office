import * as XLSX from 'xlsx';
import { PrismaClient } from '@prisma/client';
import { ProcessingResult, FIMMDA_COLUMN_MAPPING } from '../valuationTypes';
import { BaseFileProcessor } from './BaseFileProcessor';

export class FIMMDAProcessor extends BaseFileProcessor {
  constructor(prisma: PrismaClient) {
    super(prisma);
  }

  async processFile(file: Express.Multer.File, batchId: string): Promise<ProcessingResult> {
    try {
      const workbook = XLSX.read(file.buffer, {
        type: 'buffer',
        cellDates: true,
        dateNF: 'dd-mmm-yyyy'
      });

      const sheetsToProcess = ['details'];
      let allRecords: any[] = [];

      for (const sheetNameKey of sheetsToProcess) {
        const sheetName = Object.keys(workbook.Sheets).find(
          name => name.toLowerCase() === sheetNameKey
        );

        if (!sheetName) {
          console.warn(`Sheet "${sheetNameKey}" not found.`);
          continue;
        }

        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, {
          header: 1,
          raw: false,
          dateNF: 'dd-mmm-yyyy'
        });

        const headerRowIndex = this.findHeaderRow(jsonData);
        if (headerRowIndex === -1) {
          console.warn(`Header row not found in "${sheetNameKey}" sheet.`);
          continue;
        }

        const headers = (jsonData[headerRowIndex] as string[]).map(h =>
          h ? this.normalizeHeader(h.toString()) : ''
        );

        for (let i = headerRowIndex + 1; i < jsonData.length; i++) {
          const row = jsonData[i] as any[];
          if (!row || row.length === 0) continue;

          const record = this.mapRowToRecord(headers, row);
          if (record) {
            allRecords.push(record);
          }
        }
      }

      // Step 2: Clear old data for the batch
      await this.prisma.fIMMDA.deleteMany({});

      // Step 3: Process and insert records
      let processedRecords = 0;
      let errorRecords = 0;

      for (const record of allRecords) {
        try {
          const processedRecord = this.processRecord(record, batchId);
          await this.prisma.fIMMDA.create({ data: processedRecord });
          processedRecords++;
        } catch (error) {
          console.error('Error processing FIMMDA record:', error);
          errorRecords++;
        }
      }

      return {
        totalRecords: allRecords.length,
        processedRecords,
        errorRecords
      };

    } catch (error) {
      console.error('Error processing FIMMDA file:', error);
      throw error;
    }
  }

  private normalizeHeader(header: string): string {
    return header
      .toLowerCase()
      .replace(/[\r\n\t]/g, ' ')             // Replace line breaks and tabs
      .replace(/[^a-z0-9\s]/gi, '')          // Remove special characters
      .replace(/\s+/g, ' ')                  // Collapse multiple spaces
      .trim();
  }

  private findHeaderRow(data: any[]): number {
    for (let i = 0; i < Math.min(data.length, 20); i++) {
      const row = data[i];
      if (!row || !Array.isArray(row)) continue;

      const lowerRow = row.map(cell =>
        cell ? this.normalizeHeader(cell.toString()) : ''
      );

      const hasISIN = lowerRow.some(h => h.includes('isin'));
      const hasMarketPrice = lowerRow.some(h => h.includes('market price'));
      const hasCategory = lowerRow.some(h => h.includes('category'));
      const hasMarketValu = lowerRow.some(h => h.includes('mp as per valuation'));
      const hasDifference = lowerRow.some(h => h.includes('difference'));

      if (hasISIN && hasMarketPrice && hasCategory && hasMarketValu && hasDifference) {
        return i;
      }
    }
    return -1;
  }

  private mapRowToRecord(headers: string[], row: any[]): any {
    const record: any = {};
    headers.forEach((header, index) => {
      const normalizedHeader = this.normalizeHeader(header);
      const dbColumn = FIMMDA_COLUMN_MAPPING[normalizedHeader];
      if (dbColumn && row[index] !== undefined) {
        const value = this.processValue(dbColumn, row[index]);
        record[dbColumn] = value;
      }
    });

    if (!record.isin || !record.marketPrice || !record.category) {
      return null;
    }

    return record;
  }

  private processRecord(record: any, batchId: string): any {
    return {
      isin: record.isin,
      instrumentId: record.instrumentId,
      portfolio: record.portfolio,
      securityName: record.securityName,
      category: record.category,
      subCategory: record.subCategory,
      instrumentType: record.instrumentType,
      slrNslr: record.slrNslr,
      issuer: record.issuer,
      quantity: parseFloat(record.quantity),
      faceValue: parseFloat(record.faceValue),
      wap: parseFloat(record.wap),
      bookValue: parseFloat(record.bookValue),
      maturityDate: this.parseDate(record.maturityDate),
      coupon: parseFloat(record.coupon),
      marketValue: parseFloat(record.marketValue),
      marketPrice: parseFloat(record.marketPrice),
      marketPriceValuation: parseFloat(record.marketPriceValuation),
      difference: parseFloat(record.difference),
      marketYield: parseFloat(record.marketYield),
      appreciation: parseFloat(record.appreciation),
      depreciation: parseFloat(record.depreciation),
      valuationDate: this.parseDate(record.valuationDate),
      faceValuePerUnit: parseFloat(record.faceValuePerUnit),
      currentYield: parseFloat(record.currentYield),
      uploadBatchId: batchId,
    };
  }
}
